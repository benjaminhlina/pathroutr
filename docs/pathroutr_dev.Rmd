---
title: "Exploring Visibility Graphs to Route Seals Around Land"
author: "Josh M London"
date: "10/30/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r pkg-load, results='hide', message=FALSE, warning=FALSE}
library(tidyverse)
library(DBI)
library(odbc)
library(sf)
library(lwgeom)
library(ggspatial)
library(glue)
library(here)
```

## Introduction

Routing marine mammal (and other marine taxa) telemetry tracks around water has been an
issue on the wish list of bio-loggers for many years now. A number of approaches have been
pursued over the years. But, many have either required censoring/cherry-picking of data OR
extensive computational time. Here, we rely on routing technologies that many of us use
daily when we query our phones for directions from point A to point B. In brief, a network
of nodes and edges are created that represent possible paths through water (and, around
land) within the study area. This graph is then used to determine the shortest path
between two points through the network. The hope/intention is to make this process fast so
hundreds of tracks can be re-routed around land in just a few minutes or, even, seconds.

This concept is often referred to as a 'visibility graph'. Essentially, instead of a graph
that represents routes from any node to every other node through unconstrained space, a
visibility graph limits the graph connectivity to only those paths that are not blocked
by a barrier. In the simplest of forms, we would start with a polygon representing our
land barrier and extract all of the vertices as points. Then, we connect every vertex to
every other vertex with a straight line. If we remove all of the lines that cross our land
barrier, we are left with a network of 'edges' that only exist outside of the land barrier.
This approach works when the land polygons are simple and the scale is relatively small.
But, because we are connecting every vertex to every other vertex, the network
complexity increases dramatically as more points are added.

If we have any hope of a solution that is scalable and computationally efficient, we 
need a better solution for building our network of edges that traverse around land. For
this, we will turn to Delaunay Triangles. Delaunay triangles are commonly used for the
creation of meshes to describe a surface. One advantage is that smaller (denser) triangles are
created in areas with more information and areas with less information have larger triangles.
In our situation, a complicated land barrier with inlets, islands, bays, fjords, etc would
result in more detailed triangulation but larger open areas of water would contain fewer.
If we think of each line in a triangle as an edge in our network, then we end up with a
network that naturally represents the detail we need while minimizing the network size and
complexity. The final step is to, simply, remove all of the lines/edges that are wholely
within or that cross our barrier polygon.

To our knowledge, this network/graph approach has not been applied to the movement of
marine animals. The approach we outline here (and pending development within the
'pathroutr' package) is intended to be used in conjunction with a predicted track output
from a movement model (e.g. from the R package `{crawl}`). Additional advancements might
incorporate this network approach into the statistical model fitting process.

This document explores the available functionality within existing R packages (e.g.
`{igraph}`, `{sfnetworks}`). We setup an initial proof of concept within a PostgreSQL
databse with both the PostGIS and pgRouting extensions installed. Then, we will work to
port the same approach to an R-centric workflow. It is important to note that this
problem is uniquely suited for many of the advantages a spatial database provides.
Therefore, while we may find an R-centric solution, the best, most-efficient approach
may still be to rely on a spatial database.

## Creating A Testing Space

Our first step is load in a set of polygons that will represent our *land barrier* and a
set of points that will represent our potential starting and ending points. We've created
these to be somewhat representative (but still simple enough for testing) of a real world
environment we might encounter with actual movement data from a seal or other marine
mammal. Our approach will be to test implementation of our code by randomly selecting a
set of points as origin and destination features for our routing. Repeated selection of OD
points will allow robust testing.

The polygons represented here are loosely based on islands present off the north end of
Kodiak Island in Alaska. The set effectively represents inlets, bays, straits and island
features of varying size that are typical of the coastal marine environment and are also
typically challenging for routing.

```{r load-land-data}
land_barrier <- sf::st_read(here::here('inst/extdata/simple_land_barrier.gpkg')) %>% 
  st_transform(3338)
poi <- sf::st_read(here::here('inst/extdata/points_of_interest.gpkg')) %>% 
  st_transform(3338)
```

```{r base-map}
ggplot() +
  ggspatial::annotation_spatial(land_barrier, color = "cornsilk4") +
  ggspatial::layer_spatial(poi, color = "deepskyblue3") +
  theme_void()
```

## PostGIS/pgRouting Solution

The PostgreSQL database extensions PostGIS and pgRouting offer a full set of spatial and
network routing functions that we can take advantage of to prove our concept that this is
a viable approach. The ultimate goal, however, is to provide a solution with R.

In this next code chunk, we setup our connection to the local database and push our
`land_barrier` polygon up to the database while also creating a spatial index.

```{r pg-setup, results='hide'}
con <- dbConnect(
  odbc(),
  dsn = "PostgreSQL localhost",
  maxvarcharsize = 0
)

st_write(land_barrier, con, "land_barrier", layer_options = "OVERWRITE=true")

dbExecute(con,
"CREATE INDEX land_barier_gist ON land_barrier USING GIST (geometry)")
```

Now, we're ready to build our network. The steps are pretty straight forward: extract all
of the vertices from the polygon as points and create a geometry of Delaunay triangles from
those points.

```{sql, connection = con, results='hide'}
DROP TABLE IF EXISTS tri_routes;
CREATE TABLE tri_routes as 
WITH land_pts AS (
SELECT (ST_DumpPoints(geometry)).geom geometry FROM land_barrier)
SELECT (ST_Dump(ST_DelaunayTriangles(ST_Collect(land_pts.geometry), 0,1))).geom geometry 
FROM land_pts;
```

Now, we need to turn this series of lines into network that is built only from those lines
that are not within or do not cross the `land_barrier` polygons. In addition to the spatial
query we also need to set of nodes and edges based on our lines. The endpoints of each
line represents our nodes and the edges are, obviously, the lines. So, all of the spatial
information we need is there. But, a graph network needs each of those nodes indexed and
each edge defined defined as a line from a _source_ node to a _target_ node. To create this
manually would require some tedious code writing. Fortunately, the `pgRouting` extension
to PostgreSQL provides a `pgr_createTopology()` function that will do this for us.

First, we'll alter our table to create the necessary columns for our table

```{sql, connection = con, results='hide'}
ALTER TABLE tri_routes ADD COLUMN id SERIAL PRIMARY KEY;
ALTER TABLE tri_routes ADD COLUMN source integer;
ALTER TABLE tri_routes ADD COLUMN target integer;
```

The final bit we need to do is remove any of the edges in our table that cross the land
barrier polygon. We can't use the typical `ST_Intersects()` function here because all of the
nodes intersect with the polygon. So, we will use a combination of `ST_Within()` and
`ST_Crosses()` to get our final set of lines.

```{sql, connection = con, results='hide'}
DROP TABLE IF EXISTS tri_routes_noland;
CREATE TABLE tri_routes_noland AS
SELECT 
  id, 
  source, 
  target, 
  geometry
FROM
  tri_routes
WHERE
  tri_routes.id NOT IN 
  (
    SELECT 
      tri_routes.id
    FROM 
      land_barrier,
      tri_routes
    WHERE 
      ST_Within(tri_routes.geometry,land_barrier.geometry) OR
      ST_Crosses(tri_routes.geometry, land_barrier.geometry)
  );
CREATE INDEX routes_source_idx ON tri_routes_noland (source);
CREATE INDEX routes_target_idx ON tri_routes_noland (target);
```

And, lastly, we run the `pgr_createTopology()` function to create our final topology for
the network graph.

```{sql, connection = con, results='hide'}
SELECT pgr_createTopology('tri_routes_noland', 0.0001, 'geometry', 'id');
```

Now that our network is all set and ready to go, let's test it out and take it for a spin.
First, we can plot our network along with our land barrier polygons to confirm our
expectation that the routes don't cross land.

```{r}
tri_routes_noland <- st_read(con, "tri_routes_noland")
ggplot() +
  ggspatial::annotation_spatial(land_barrier, fill = "cornsilk3", size = 0) +
  ggspatial::layer_spatial(tri_routes_noland, color = "deepskyblue3") +
  theme_void()
```

Next up, we can select two random nodes from our network and calculate the shortest path
based on the Djikstra algorithm. For this, we will pass the length of the edge as the cost
so we are insured to get the shortest path not just the path with the minimal number of nodes.
To check that we really have a working solution, we'll run this query 1000 times.

```{r, warning=FALSE, message=FALSE}

sql_query <- "WITH rnd_source AS (select source from tri_routes_noland ORDER BY random() limit 1),
rnd_target AS (select target from tri_routes_noland ORDER BY random() limit 1)
SELECT seq, (select source from rnd_source) as source, (select target from rnd_target) as target, node, edge, cost as cost, geometry
FROM pgr_dijkstra(
'SELECT id, source, target, st_length(geometry) as cost, st_length(geometry) as reverse_cost FROM tri_routes_noland',
(SELECT source FROM rnd_source),(SELECT target FROM rnd_target), directed := FALSE) as pt
JOIN tri_routes_noland ON pt.edge = tri_routes_noland.id;"

rnd_shortpath <- function() {
  p <- st_read(dsn = con, query = sql_query) 
  if(nrow(p) == 0) return(NULL)
  l <- p %>% summarise(do_union = FALSE) %>% st_line_merge()
  return(l)
}

path_list <- vector("list", 1000)

for(i in 1:length(path_list)) {
  path_list[[i]] <- rnd_shortpath()
}

shortpaths <- do.call(rbind, path_list)

ggplot() +
  ggspatial::annotation_spatial(land_barrier, fill = "cornsilk3", size = 0) +
  ggspatial::layer_spatial(shortpaths, color = "deepskyblue3", alpha = 0.2) +
  theme_void()

```

This seems to demonstrate that our approach is pretty robust. The next test is to test the
routing between our points of interest (which are not nodes in our network). We could 
implement this entirely within the suite of PostGIS/pgRouting tools. But, here, we'll
take a hybrid approach where we rely on {sf} package to identify the nearest node to a
given point of interest and, then, query the database for the shortest path.

The `pgr_shortpath()` function below is rather complicated, but it reflects the complexity
involved in reliably determining the nearest node and also extending the network path to
include the starting and ending points.

```{r}
pgr_shortpath <- function(data, con, tbl_edges, tbl_nodes = paste0(tbl_edges,"_vertices_pgr")) {
  nodes <- st_read(con, tbl_nodes)
  edges <- st_read(con, tbl_edges)
  start_pt <- data[1,]
  end_pt <- data[2,]
  
  start_edge <- st_nearest_feature(start_pt,edges)
  end_edge <- st_nearest_feature(end_pt, edges)
  
  start_nodes <- c(edges[start_edge, ]$source,
                   edges[start_edge, ]$target
  )
  
  end_nodes <- c(edges[end_edge, ]$source,
                   edges[end_edge, ]$target
  )
  
  start_node <- st_nearest_feature(start_pt, nodes[start_nodes,])
  start_node <- nodes[start_nodes, ][[start_node,"id"]]
  
  end_node <- st_nearest_feature(end_pt, nodes[end_nodes,])
  end_node <- nodes[end_nodes, ][[end_node,"id"]]
  
  sql <- glue::glue("
  SELECT seq, source, target, node, edge, cost as cost, geometry
  FROM pgr_dijkstra(
  'SELECT id, source, target, st_length(geometry) as cost, 
  st_length(geometry) as reverse_cost FROM {tbl_edges}',
  {start_node},
  {end_node}, 
  directed := FALSE) as pt
JOIN {tbl_edges} ON pt.edge = {tbl_edges}.id
  ")
  
  p <- st_read(dsn = con, query = sql) 
  if(nrow(p) == 0) return(NULL)
  
  l <- p %>% summarise(do_union = FALSE) %>% st_line_merge()
  start_idx <- st_nearest_feature(start_pt, c(st_startpoint(l), st_endpoint(l)))
  end_idx <- st_nearest_feature(end_pt, c(st_startpoint(l), st_endpoint(l)))
  l_start <- c(st_startpoint(l),st_endpoint(l))[start_idx,]
  l_end <- c(st_startpoint(l),st_endpoint(l))[end_idx,]
  
  l1 <- rbind(
    start_pt %>% st_cast('POINT'),
    l_start %>% st_sf()
  ) %>% summarise(do_union = FALSE) %>% 
    st_cast('LINESTRING')
  l2 <- rbind(
    l_end %>% st_sf(),
    end_pt %>% st_cast('POINT')
  ) %>% summarise(do_union = FALSE) %>% 
    st_cast('LINESTRING')
  
  l <- rbind(l1,l,l2) %>% 
    summarise(do_union = FALSE) %>% 
    st_cast('LINESTRING')
  
  return(l)
}
```

With our function established, we can test it by selecting 500 random pairs of points from
our `poi` data set and returning the shortest path through our visibility graph. Initial
benchmarking of this approach indicates about 56 seconds to solve all 500 paths.

```{r, message=FALSE, warning=FALSE}
random_ab_paths <- vector(mode = "list", length = 500L)

for (i in 1:length(random_ab_paths)) {
  random_ab_paths[[i]] <- poi %>% 
  slice_sample(n = 2) %>% 
  pgr_shortpath(con = con, tbl_edges = "tri_routes_noland") 
}

paths <- do.call(rbind,random_ab_paths)

ggplot() + 
  ggspatial::annotation_spatial(land_barrier, fill = "cornsilk3", size = 0) +
  ggspatial::layer_spatial(poi) +
  ggspatial::layer_spatial(paths, color = "deepskyblue3", alpha = 0.2) +
  theme_void()
```

## R implementation

Ok, now let's try and make all of this work completely within R

```{r}
library(tidyverse)
library(sf)
library(lwgeom)
library(sfnetworks)
library(tidygraph)
library(ggspatial)
library(tictoc)
```

### spatial predicate functions

```{r}
not_within <- function(x,y) !st_within(x,y)
not_crosses <- function(x,y) !st_crosses(x,y)
```

A key component to creating our visual graph is the ability to remove lines/edges that
cross our barrier polygon. the `sf::st_filter()` function cannot accept a negated
spatial predicate (e.g. `!st_intersects()`). But, it can accept a custom predicate 
function. So, we create two here. `not_within()` will remove all of the lines that cross
completely within a polygon from one node to another. Note, if a buffer value is passed
to our `prt_visgraph()` function, this will likely not return any lines. The function
`not_crosses()` handles the situation where an edge crosses over a portion of the
barrier polygon

### identifying the nearest node

The `sfnetwork::spatial_shortest_path()` function will find the nearest nodes to a given
set of start and end points and solve the shortest path based on those nodes. 
However, it is technically possible for the nearest node to not be associated with the
nearest edge. This function is an attempt to address that ...but, for now, we do not
suggest implementing this as it dramatically increases the computation time and the
potential impact on desired outcomes is negligible.

```{r}
prt_nearest_node <- function(n, p) {
  i <- st_nearest_feature(p, n %>% activate("edges"))
  edge <- n %>% activate("edges") %>% 
    slice(i) %>% st_as_sf()
  nodes <- n %>% activate("nodes") %>% 
    slice(c(edge$from, edge$to)) %>% st_as_sf()
  near_node <- st_nearest_feature(p, nodes)
  near_node <- edge[[1,near_node]]
}
```

### create a visibility graph

A few R packages exist for creating Delaunay Triangles across a landscape (`{deldir}`, 
`{anglr}`, `{geometry}`, `{RTriangle}`). For simplicity, we are starting with the 
`st_triangulate()` function that is included with the `{sf}` package. The other approaches
may very well be more efficient, especially at even larger scales, and are worth further
investigation. But, for now, the easy integration with typical `{sf}` workflows is a key
benefit. 

We are also relying on the `{sfnetwork}` package that is indevelopment and available on
github. This package does much of the heavy lifting needed to translate between `{sf}` and
`{igraph}` worlds and we are excited to see this package continue to develop and improve.

```{r}
prt_visgraph <- function(barrier, buffer = 0, centroids = TRUE, aug_points = NULL) {
  barrier <- st_union(
    st_cast(barrier, 'POLYGON')
  )
  
  if(buffer>0) {
    buf_poly <- barrier %>% st_buffer(buffer)
  } else {
    buf_poly <- barrier
  }
  
  if (centroids) {
  ctr_pts <- st_centroid(
    st_collection_extract(
    st_triangulate(
    st_cast(buf_poly, 'MULTIPOINT')
  ),
    'POLYGON')
  )
  
  edges <- c(
    buf_poly %>% st_cast('MULTIPOINT') %>% st_cast('POINT'), 
    ctr_pts
    ) %>% 
    st_union() %>% 
    sf::st_triangulate(bOnlyEdges = TRUE) %>% 
    sf::st_cast('LINESTRING') %>% 
    sf::st_sf()%>% 
    sf::st_filter(barrier, .predicate = not_within) %>% 
    sf::st_filter(barrier, .predicate = not_crosses)
  }
  
  n <- sfnetworks::as_sfnetwork(edges, directed = FALSE) %>% 
  activate("edges") %>% 
  mutate(length = edge_length())
  
  return(n)
}
```

This function is relatively straightforward. The first argument is a user provided
_barrier_ polygon. In our typical use case, this is a polygon representation of land
within the study area. This needs to be cast into a collection of _'POLYGON'_ features in
cases where the user provides a _'MULTIPOLYGON'_ feature. Future implementations should
run a series of validity checks on the user supplied object to insure success and provide
guidance if the validity checks fail. The second argument is a _buffer_ to be applied to
the _barrier_. The default of _no buffer_ will result in all of the routes intersecting
with the _barrier_ polygon and this may cause downstream complications. The size of the
buffer is species specific. Another option marine researchers might consider is providing
a barrier polygon created from a minimum isobath value appropriate for the species of
interest. Another consideration regarding the use of a buffer is that is may allow use of
a less detailed and complex land polygon. Computational time and stress will increase as
the barrier polygon detail increases. The _centroids_ argument specifies whether to add
additional nodes to the centroids of the Delaunay triangles. This will typically result in
more realistic and smoother paths but will increase complexity and computational time.
Finally, there is an option to provide an additional set of _aug_points_ to further
improve the resulting mesh. The most likely use of this would be to pass points from one
or more animal tracks. That would insure more mesh detail is created in the regions used
by the animal(s).

The visibility graph is created by removing all of the edges that cross land. For this,
we'll use our custom spatial predicate functions and filter those edges out of our graph.
The final step is create our network via `as_sfnetwork()` function. It is critical that
_directed = FALSE_ be passed at this stage so that an undirected network is created. We
also create a _length_ column that represents edge length and will be used as our weight
parameter when determining the shortest path between points.

### finding the shortest path

```{r}
prt_shortpath <- function(n, p1, p2) {

  p1 <- st_cast(p1, 'POINT')
  p2 <- st_cast(p2, 'POINT')
  
  # n1 <- prt_nearest_node(n, p1)
  # n2 <- prt_nearest_node(n, p2)
  
  l <- try(convert(n, to_spatial_shortest_paths,
                   p1, p2,
                   weights = "length"))
  
  if (length(st_geometry(l)) > 0) {
    l <- l %>% st_as_sf() %>%
      summarise(do_union = FALSE) %>%
      st_line_merge()
    start_idx <-
      st_nearest_feature(p1, c(st_startpoint(l), st_endpoint(l)))
    end_idx <-
      st_nearest_feature(p2, c(st_startpoint(l), st_endpoint(l)))
    l_start <- c(st_startpoint(l), st_endpoint(l))[start_idx, ]
    l_end <- c(st_startpoint(l), st_endpoint(l))[end_idx, ]
    
    l1 <- rbind(p1 %>% st_cast('POINT'),
                l_start %>% st_sf()) %>%
      summarise(do_union = FALSE) %>%
      st_cast('LINESTRING')
    
    l2 <- rbind(l_end %>% st_sf(),
                p2 %>% st_cast('POINT')) %>%
      summarise(do_union = FALSE) %>%
      st_cast('LINESTRING')
    
    l <- rbind(l1, l, l2) %>%
      summarise(do_union = FALSE) %>% 
      st_line_merge()
  } else
    l <- NULL
  return(l)
}
```

The `prt_shortpath()` is built around the `spatial_shortest_paths()` function within the
`{sfnetwork}` package. We access this function via the `convert()` morphing function in the
`{tidygraph}` which returns a _'LINESTRING'_ that represents the shortest path along our
visibility graph between the nodes nearest our specified start and end points. We need to
do some additional investigation and manipulation (identify the nearest end points to the
returned line and, then, create lines between those end points and our points) in order to return the complete path from start to end. 

### simulated example

Let's return to our example land barrier and our set of points of interest we used in the
PostGIS/pgRouting example

```{r}
land_barrier <- sf::st_read(here::here('inst/extdata/simple_land_barrier.gpkg')) %>% 
  st_transform(3338)
poi <- sf::st_read(here::here('inst/extdata/points_of_interest.gpkg')) %>% 
  st_transform(3338)
```

We'll take this land barrier and create a visual graph using our `prt_visgraph()`
function and a buffer of 150 meters.

```{r}
vis_graph <- prt_visgraph(land_barrier, buffer = 150)

vis_graph_sf <- vis_graph %>% activate("edges") %>% 
  st_as_sf()
ggplot() + 
  ggspatial::annotation_spatial(data = land_barrier, 
                                fill = "cornsilk3", size = 0) +
  ggspatial::layer_spatial(data = vis_graph_sf,
                           color = "deepskyblue3",
                           lwd = 0.25) +
  theme_void()
  
```

Next, we'll draw a random sample of 500 pairs from our points of interest and calculate
the shortest path between those points

```{r}
# tic()
random_ab_paths <- vector(mode = "list", length = 500L)

for (i in 1:length(random_ab_paths)) {
  ab_points <- poi %>% 
  slice_sample(n = 2)
  
  random_ab_paths[[i]] <- 
    prt_shortpath(vis_graph, ab_points[1,], ab_points[2,])
}

paths <- do.call(rbind,random_ab_paths)
# toc()

ggplot() + 
  ggspatial::annotation_spatial(land_barrier, fill = "cornsilk3", size = 0) +
  ggspatial::layer_spatial(poi) +
  ggspatial::layer_spatial(paths, color = "deepskyblue3", alpha = 0.2) +
  theme_void()

```

